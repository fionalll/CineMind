import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import axios from 'axios';
import { GoogleGenerativeAI } from '@google/generative-ai';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Load .env file from backend directory
dotenv.config({ path: path.join(__dirname, '.env') });

const app = express();
const PORT = process.env.PORT || 5000;

// Middleware
app.use(cors());
app.use(express.json());

// Initialize Gemini AI
const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);

// TMDB API configuration
const TMDB_API_KEY = process.env.TMDB_API_KEY;
const TMDB_BASE_URL = 'https://api.themoviedb.org/3';

// Helper function to search movies on TMDB
async function searchMovieOnTMDB(movieRecommendation) {
  const { title, year, reason } = movieRecommendation;
  try {
    console.log(`ğŸ” Searching for movie: ${title} (${year})`);
    
    const response = await axios.get(`${TMDB_BASE_URL}/search/movie`, {
      params: {
        api_key: TMDB_API_KEY,
        query: title,
        year: year, // YÄ±l parametresini ekle
        language: 'tr-TR'
      }
    });

    if (response.data.results && response.data.results.length > 0) {
      const movie = response.data.results[0];
      return {
        id: movie.id,
        title: movie.title,
        originalTitle: movie.original_title,
        overview: movie.overview,
        posterPath: movie.poster_path ? `https://image.tmdb.org/t/p/w500${movie.poster_path}` : null,
        releaseDate: movie.release_date,
        voteAverage: movie.vote_average,
        voteCount: movie.vote_count,
        backdropPath: movie.backdrop_path ? `https://image.tmdb.org/t/p/w1280${movie.backdrop_path}` : null,
        reason: reason // Gemini'nin Ã¶neri sebebini ekle
      };
    }
    return null;
  } catch (error) {
    console.error(`ğŸš¨ Movie search API isteÄŸi sÄ±rasÄ±nda detaylÄ± hata (${title} - ${year}):`, {
      message: error.message,
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data,
      config: {
        url: error.config?.url,
        params: error.config?.params
      },
      code: error.code,
      searchQuery: { title, year }
    });
    return null;
  }
}

// Main recommendation endpoint
app.post('/api/get-recommendations', async (req, res) => {
  try {
    // GÃ¼venli destructuring ile default deÄŸerler ata
    const { message, excludedTitles = [] } = req.body;

    // Ä°stekte mesaj yoksa hata dÃ¶ndÃ¼r
    if (!message) {
      return res.status(400).json({ error: 'Mesaj gerekli' });
    }

    // excludedTitles'Ä±n gÃ¼venli kontrolÃ¼ ve prompt oluÅŸturma
    const excludedMoviesText = (excludedTitles && Array.isArray(excludedTitles) && excludedTitles.length > 0) 
      ? ` LÃ¼tfen ÅŸu filmleri Ã¶nerme: [${excludedTitles.join(', ')}]` 
      : '';

    // Create prompt for Gemini
    const prompt = `Sen, dÃ¼nya sinemasÄ± konusunda uzman bir film kÃ¼ratÃ¶rÃ¼sÃ¼n. KullanÄ±cÄ±nÄ±n verdiÄŸi isteÄŸe gÃ¶re tematik, yÃ¶netmen stili veya anlatÄ± yapÄ±sÄ± olarak benzer, ancak popÃ¼ler, bariz olmayan veya yeni Ã§Ä±kan filmler Ã¶nereceksin. CevabÄ±nÄ±, iÃ§erisinde bir 'summaryText' ve 'recommendations' listesi olan tek bir JSON nesnesi olarak ver. 'recommendations' listesindeki her film bir nesne olmalÄ± ve 'title' (filmin orijinal adÄ±), 'year' (yapÄ±m yÄ±lÄ±) ve 'reason' (bu filmi neden Ã¶nerdiÄŸine dair 1-2 cÃ¼mlelik kÄ±sa bir aÃ§Ä±klama) alanlarÄ±nÄ± iÃ§ermelidir. Maksimum 5 film Ã¶ner.

    KullanÄ±cÄ± isteÄŸi: ${message}${excludedMoviesText}
    
    CevabÄ±nÄ± sadece ve sadece aÅŸaÄŸÄ±daki formatta bir JSON nesnesi olarak dÃ¶ndÃ¼r:
    {
      "summaryText": "KullanÄ±cÄ±nÄ±n isteÄŸine gÃ¶re oluÅŸturduÄŸun kÄ±sa bir giriÅŸ cÃ¼mlesi.",
      "recommendations": [
        {
          "title": "Film AdÄ± 1",
          "year": YYYY,
          "reason": "Bu filmi Ã¶nerme sebebin..."
        },
        {
          "title": "Film AdÄ± 2",
          "year": YYYY,
          "reason": "Bu filmi Ã¶nerme sebebin..."
        }
      ]
    }`;

    // Debug log - istek bilgilerini logla
    console.log('ğŸ¬ Film Ã¶nerisi isteÄŸi alÄ±ndÄ±:');
    console.log('- Mesaj:', message);
    console.log('- HariÃ§ tutulacak filmler:', excludedTitles);
    console.log('- Prompt uzunluÄŸu:', prompt.length);

    // Get recommendations from Gemini
    const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
    const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text();

    console.log('ğŸ¤– Gemini yanÄ±tÄ± alÄ±ndÄ±, uzunluk:', text.length);

    // Parse the JSON response
    let parsedResponse;
    try {
      // Clean the response text and parse JSON
      const cleanText = text.replace(/```json|```/g, '').trim();
      parsedResponse = JSON.parse(cleanText);
    } catch (parseError) {
      console.error('âŒ Gemini yanÄ±tÄ± parse edilemedi:', parseError);
      console.error('Ham yanÄ±t:', text);
      return res.status(500).json({ 
        error: 'AI yanÄ±tÄ± iÅŸlenirken hata oluÅŸtu',
        aiResponse: text
      });
    }

    if (!parsedResponse.recommendations || !Array.isArray(parsedResponse.recommendations)) {
      console.error('âŒ Gemini geÃ§ersiz format dÃ¶ndÃ¼rdÃ¼:', parsedResponse);
      return res.status(500).json({ 
        error: 'AI geÃ§ersiz format dÃ¶ndÃ¼rdÃ¼',
        aiResponse: text
      });
    }

    console.log('âœ… Gemini yanÄ±tÄ± parse edildi, film sayÄ±sÄ±:', parsedResponse.recommendations.length);

    // Search each movie on TMDB
    const moviePromises = parsedResponse.recommendations.map(movieRecommendation => 
      searchMovieOnTMDB(movieRecommendation)
    );
    const movieResults = await Promise.all(moviePromises);

    // Filter out null results
    const validMovies = movieResults.filter(movie => movie !== null);

    console.log('ğŸ­ TMDB aramasÄ± tamamlandÄ±, bulunan film sayÄ±sÄ±:', validMovies.length);

    res.json({
      message: parsedResponse.summaryText || `Ä°ÅŸte "${message}" isteÄŸinize gÃ¶re seÃ§tiÄŸim Ã¶zel filmler:`,
      movies: validMovies,
      originalQuery: message
    });

  } catch (error) {
    // KapsamlÄ± hata loglama
    console.error('--- RECOMMENDATION ENDPOINT ERROR ---');
    console.error('Timestamp:', new Date().toISOString());
    console.error('Error Name:', error.name);
    console.error('Error Message:', error.message);
    console.error('Error Stack:', error.stack);
    console.error('Request Body:', req.body);
    
    // EÄŸer Axios hatasÄ± ise, daha detaylÄ± bilgi
    if (error.response) {
      console.error('HTTP Response Status:', error.response.status);
      console.error('HTTP Response Data:', error.response.data);
    }
    
    // EÄŸer Gemini API hatasÄ± ise
    if (error.message && error.message.includes('Gemini')) {
      console.error('Gemini API Error Details:', error);
    }
    
    console.error('Full Error Object:', JSON.stringify(error, Object.getOwnPropertyNames(error), 2));
    console.error('--- END OF ERROR REPORT ---');
    
    res.status(500).json({ 
      error: 'Sunucu hatasÄ± oluÅŸtu',
      details: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Health check endpoint
app.get('/api/health', (req, res) => {
  res.json({ status: 'OK', message: 'CineMind Backend is running' });
});

// Test endpoint for TMDB connection
app.get('/api/test-tmdb', async (req, res) => {
  try {
    const response = await axios.get(`${TMDB_BASE_URL}/movie/popular`, {
      params: {
        api_key: TMDB_API_KEY,
        language: 'tr-TR'
      }
    });
    res.json({ status: 'TMDB connection successful', data: response.data.results.slice(0, 3) });
  } catch (error) {
    res.status(500).json({ status: 'TMDB connection failed', error: error.message });
  }
});

// Test endpoint for Gemini models
app.get('/api/test-gemini', async (req, res) => {
  try {
    const model = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });
    const result = await model.generateContent("Hello, test message");
    const response = await result.response;
    const text = response.text();
    res.json({ status: 'Gemini connection successful', response: text });
  } catch (error) {
    res.status(500).json({ status: 'Gemini connection failed', error: error.message });
  }
});

// Get movie genres
app.get('/api/genres', async (req, res) => {
  try {
    console.log('ğŸ­ Fetching genres from TMDB...');
    console.log('TMDB_API_KEY exists:', !!TMDB_API_KEY);
    
    const response = await axios.get(`${TMDB_BASE_URL}/genre/movie/list`, {
      params: {
        api_key: TMDB_API_KEY,
        language: 'tr-TR'
      }
    });
    res.json(response.data);
  } catch (error) {
    console.error('ğŸš¨ Genres API isteÄŸi sÄ±rasÄ±nda detaylÄ± hata:', {
      message: error.message,
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data,
      config: {
        url: error.config?.url,
        params: error.config?.params
      },
      code: error.code
    });
    res.status(500).json({ status: 'Failed to fetch genres', error: error.message });
  }
});

// Get popular movies
app.get('/api/movies/popular', async (req, res) => {
  try {
    console.log('ğŸ¬ Fetching popular movies from TMDB...');
    console.log('TMDB_API_KEY exists:', !!TMDB_API_KEY);
    
    const response = await axios.get(`${TMDB_BASE_URL}/movie/popular`, {
      params: {
        api_key: TMDB_API_KEY,
        language: 'tr-TR',
        page: req.query.page || 1
      }
    });
    
    const movies = response.data.results.map(movie => ({
      id: movie.id,
      title: movie.title,
      originalTitle: movie.original_title,
      overview: movie.overview,
      posterPath: movie.poster_path ? `https://image.tmdb.org/t/p/w500${movie.poster_path}` : null,
      backdropPath: movie.backdrop_path ? `https://image.tmdb.org/t/p/w1280${movie.backdrop_path}` : null,
      releaseDate: movie.release_date,
      voteAverage: movie.vote_average,
      voteCount: movie.vote_count
    }));

    res.json({
      ...response.data,
      results: movies
    });
  } catch (error) {
    console.error('ğŸš¨ Popular movies API isteÄŸi sÄ±rasÄ±nda detaylÄ± hata:', {
      message: error.message,
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data,
      config: {
        url: error.config?.url,
        params: error.config?.params
      },
      code: error.code
    });
    res.status(500).json({ status: 'Failed to fetch popular movies', error: error.message });
  }
});

// Get top rated movies
app.get('/api/movies/top-rated', async (req, res) => {
  try {
    console.log('â­ Fetching top rated movies from TMDB...');
    console.log('TMDB_API_KEY exists:', !!TMDB_API_KEY);
    
    const response = await axios.get(`${TMDB_BASE_URL}/movie/top_rated`, {
      params: {
        api_key: TMDB_API_KEY,
        language: 'tr-TR',
        page: req.query.page || 1
      }
    });
    
    const movies = response.data.results.map(movie => ({
      id: movie.id,
      title: movie.title,
      originalTitle: movie.original_title,
      overview: movie.overview,
      posterPath: movie.poster_path ? `https://image.tmdb.org/t/p/w500${movie.poster_path}` : null,
      backdropPath: movie.backdrop_path ? `https://image.tmdb.org/t/p/w1280${movie.backdrop_path}` : null,
      releaseDate: movie.release_date,
      voteAverage: movie.vote_average,
      voteCount: movie.vote_count
    }));

    res.json({
      ...response.data,
      results: movies
    });
  } catch (error) {
    console.error('ğŸš¨ Top rated movies API isteÄŸi sÄ±rasÄ±nda detaylÄ± hata:', {
      message: error.message,
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data,
      config: {
        url: error.config?.url,
        params: error.config?.params
      },
      code: error.code
    });
    res.status(500).json({ status: 'Failed to fetch top rated movies', error: error.message });
  }
});

// Get upcoming movies
app.get('/api/movies/upcoming', async (req, res) => {
  try {
    console.log('ğŸ¯ Fetching upcoming movies from TMDB...');
    console.log('TMDB_API_KEY exists:', !!TMDB_API_KEY);
    
    const response = await axios.get(`${TMDB_BASE_URL}/movie/upcoming`, {
      params: {
        api_key: TMDB_API_KEY,
        language: 'tr-TR',
        page: req.query.page || 1
      }
    });
    
    const movies = response.data.results.map(movie => ({
      id: movie.id,
      title: movie.title,
      originalTitle: movie.original_title,
      overview: movie.overview,
      posterPath: movie.poster_path ? `https://image.tmdb.org/t/p/w500${movie.poster_path}` : null,
      backdropPath: movie.backdrop_path ? `https://image.tmdb.org/t/p/w1280${movie.backdrop_path}` : null,
      releaseDate: movie.release_date,
      voteAverage: movie.vote_average,
      voteCount: movie.vote_count
    }));

    res.json({
      ...response.data,
      results: movies
    });
  } catch (error) {
    console.error('ğŸš¨ Upcoming movies API isteÄŸi sÄ±rasÄ±nda detaylÄ± hata:', {
      message: error.message,
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data,
      config: {
        url: error.config?.url,
        params: error.config?.params
      },
      code: error.code
    });
    res.status(500).json({ status: 'Failed to fetch upcoming movies', error: error.message });
  }
});

// Discover movies by genre
app.get('/api/movies/by-genre/:genreId', async (req, res) => {
  try {
    const { genreId } = req.params;
    console.log(`ğŸ¨ Fetching movies for genre ${genreId} from TMDB...`);
    console.log('TMDB_API_KEY exists:', !!TMDB_API_KEY);
    
    const response = await axios.get(`${TMDB_BASE_URL}/discover/movie`, {
      params: {
        api_key: TMDB_API_KEY,
        language: 'tr-TR',
        with_genres: genreId,
        page: req.query.page || 1,
        sort_by: 'popularity.desc'
      }
    });
    
    const movies = response.data.results.map(movie => ({
      id: movie.id,
      title: movie.title,
      originalTitle: movie.original_title,
      overview: movie.overview,
      posterPath: movie.poster_path ? `https://image.tmdb.org/t/p/w500${movie.poster_path}` : null,
      backdropPath: movie.backdrop_path ? `https://image.tmdb.org/t/p/w1280${movie.backdrop_path}` : null,
      releaseDate: movie.release_date,
      voteAverage: movie.vote_average,
      voteCount: movie.vote_count
    }));

    res.json({
      ...response.data,
      results: movies
    });
  } catch (error) {
    console.error('ğŸš¨ Movies by genre API isteÄŸi sÄ±rasÄ±nda detaylÄ± hata:', {
      message: error.message,
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data,
      config: {
        url: error.config?.url,
        params: error.config?.params
      },
      code: error.code,
      genreId: req.params.genreId
    });
    res.status(500).json({ status: 'Failed to fetch movies by genre', error: error.message });
  }
});

// =================== TV SHOWS ENDPOINTS ===================

// Get popular TV shows
app.get('/api/tv/popular', async (req, res) => {
  try {
    console.log('ğŸ“º Fetching popular TV shows from TMDB...');
    console.log('TMDB_API_KEY exists:', !!TMDB_API_KEY);
    
    const response = await axios.get(`${TMDB_BASE_URL}/tv/popular`, {
      params: {
        api_key: TMDB_API_KEY,
        language: 'tr-TR',
        page: req.query.page || 1
      }
    });
    
    const tvShows = response.data.results.map(show => ({
      id: show.id,
      title: show.name, // TV shows use 'name' instead of 'title'
      originalTitle: show.original_name,
      overview: show.overview,
      posterPath: show.poster_path ? `https://image.tmdb.org/t/p/w500${show.poster_path}` : null,
      backdropPath: show.backdrop_path ? `https://image.tmdb.org/t/p/w1280${show.backdrop_path}` : null,
      releaseDate: show.first_air_date, // TV shows use 'first_air_date'
      voteAverage: show.vote_average,
      voteCount: show.vote_count,
      media_type: 'tv'
    }));

    res.json({
      ...response.data,
      results: tvShows
    });
  } catch (error) {
    console.error('ğŸš¨ Popular TV shows API isteÄŸi sÄ±rasÄ±nda detaylÄ± hata:', {
      message: error.message,
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data,
      config: {
        url: error.config?.url,
        params: error.config?.params
      },
      code: error.code
    });
    res.status(500).json({ status: 'Failed to fetch popular TV shows', error: error.message });
  }
});

// Get top rated TV shows
app.get('/api/tv/top-rated', async (req, res) => {
  try {
    console.log('â­ Fetching top rated TV shows from TMDB...');
    console.log('TMDB_API_KEY exists:', !!TMDB_API_KEY);
    
    const response = await axios.get(`${TMDB_BASE_URL}/tv/top_rated`, {
      params: {
        api_key: TMDB_API_KEY,
        language: 'tr-TR',
        page: req.query.page || 1
      }
    });
    
    const tvShows = response.data.results.map(show => ({
      id: show.id,
      title: show.name,
      originalTitle: show.original_name,
      overview: show.overview,
      posterPath: show.poster_path ? `https://image.tmdb.org/t/p/w500${show.poster_path}` : null,
      backdropPath: show.backdrop_path ? `https://image.tmdb.org/t/p/w1280${show.backdrop_path}` : null,
      releaseDate: show.first_air_date,
      voteAverage: show.vote_average,
      voteCount: show.vote_count,
      media_type: 'tv'
    }));

    res.json({
      ...response.data,
      results: tvShows
    });
  } catch (error) {
    console.error('ğŸš¨ Top rated TV shows API isteÄŸi sÄ±rasÄ±nda detaylÄ± hata:', {
      message: error.message,
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data,
      config: {
        url: error.config?.url,
        params: error.config?.params
      },
      code: error.code
    });
    res.status(500).json({ status: 'Failed to fetch top rated TV shows', error: error.message });
  }
});

// Get airing today TV shows
app.get('/api/tv/airing-today', async (req, res) => {
  try {
    console.log('ğŸ“º Fetching airing today TV shows from TMDB...');
    console.log('TMDB_API_KEY exists:', !!TMDB_API_KEY);
    
    const response = await axios.get(`${TMDB_BASE_URL}/tv/airing_today`, {
      params: {
        api_key: TMDB_API_KEY,
        language: 'tr-TR',
        page: req.query.page || 1
      }
    });
    
    const tvShows = response.data.results.map(show => ({
      id: show.id,
      title: show.name,
      originalTitle: show.original_name,
      overview: show.overview,
      posterPath: show.poster_path ? `https://image.tmdb.org/t/p/w500${show.poster_path}` : null,
      backdropPath: show.backdrop_path ? `https://image.tmdb.org/t/p/w1280${show.backdrop_path}` : null,
      releaseDate: show.first_air_date,
      voteAverage: show.vote_average,
      voteCount: show.vote_count,
      media_type: 'tv'
    }));

    res.json({
      ...response.data,
      results: tvShows
    });
  } catch (error) {
    console.error('ğŸš¨ Airing today TV shows API isteÄŸi sÄ±rasÄ±nda detaylÄ± hata:', {
      message: error.message,
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data,
      config: {
        url: error.config?.url,
        params: error.config?.params
      },
      code: error.code
    });
    res.status(500).json({ status: 'Failed to fetch airing today TV shows', error: error.message });
  }
});

// Get on the air TV shows
app.get('/api/tv/on-the-air', async (req, res) => {
  try {
    console.log('ğŸ“º Fetching on the air TV shows from TMDB...');
    console.log('TMDB_API_KEY exists:', !!TMDB_API_KEY);
    
    const response = await axios.get(`${TMDB_BASE_URL}/tv/on_the_air`, {
      params: {
        api_key: TMDB_API_KEY,
        language: 'tr-TR',
        page: req.query.page || 1
      }
    });
    
    const tvShows = response.data.results.map(show => ({
      id: show.id,
      title: show.name,
      originalTitle: show.original_name,
      overview: show.overview,
      posterPath: show.poster_path ? `https://image.tmdb.org/t/p/w500${show.poster_path}` : null,
      backdropPath: show.backdrop_path ? `https://image.tmdb.org/t/p/w1280${show.backdrop_path}` : null,
      releaseDate: show.first_air_date,
      voteAverage: show.vote_average,
      voteCount: show.vote_count,
      media_type: 'tv'
    }));

    res.json({
      ...response.data,
      results: tvShows
    });
  } catch (error) {
    console.error('ğŸš¨ On the air TV shows API isteÄŸi sÄ±rasÄ±nda detaylÄ± hata:', {
      message: error.message,
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data,
      config: {
        url: error.config?.url,
        params: error.config?.params
      },
      code: error.code
    });
    res.status(500).json({ status: 'Failed to fetch on the air TV shows', error: error.message });
  }
});

// Discover TV shows by genre
app.get('/api/tv/by-genre/:genreId', async (req, res) => {
  try {
    const { genreId } = req.params;
    console.log(`ğŸ¨ Fetching TV shows for genre ${genreId} from TMDB...`);
    console.log('TMDB_API_KEY exists:', !!TMDB_API_KEY);
    
    const response = await axios.get(`${TMDB_BASE_URL}/discover/tv`, {
      params: {
        api_key: TMDB_API_KEY,
        language: 'tr-TR',
        with_genres: genreId,
        page: req.query.page || 1,
        sort_by: 'popularity.desc'
      }
    });
    
    const tvShows = response.data.results.map(show => ({
      id: show.id,
      title: show.name,
      originalTitle: show.original_name,
      overview: show.overview,
      posterPath: show.poster_path ? `https://image.tmdb.org/t/p/w500${show.poster_path}` : null,
      backdropPath: show.backdrop_path ? `https://image.tmdb.org/t/p/w1280${show.backdrop_path}` : null,
      releaseDate: show.first_air_date,
      voteAverage: show.vote_average,
      voteCount: show.vote_count,
      media_type: 'tv'
    }));

    res.json({
      ...response.data,
      results: tvShows
    });
  } catch (error) {
    console.error('ğŸš¨ TV shows by genre API isteÄŸi sÄ±rasÄ±nda detaylÄ± hata:', {
      message: error.message,
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data,
      config: {
        url: error.config?.url,
        params: error.config?.params
      },
      code: error.code,
      genreId: req.params.genreId
    });
    res.status(500).json({ status: 'Failed to fetch TV shows by genre', error: error.message });
  }
});

// Get TV genres
app.get('/api/tv/genres', async (req, res) => {
  try {
    console.log('ğŸ­ Fetching TV genres from TMDB...');
    console.log('TMDB_API_KEY exists:', !!TMDB_API_KEY);
    
    const response = await axios.get(`${TMDB_BASE_URL}/genre/tv/list`, {
      params: {
        api_key: TMDB_API_KEY,
        language: 'tr-TR'
      }
    });
    res.json(response.data);
  } catch (error) {
    console.error('ğŸš¨ TV Genres API isteÄŸi sÄ±rasÄ±nda detaylÄ± hata:', {
      message: error.message,
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data,
      config: {
        url: error.config?.url,
        params: error.config?.params
      },
      code: error.code
    });
    res.status(500).json({ status: 'Failed to fetch TV genres', error: error.message });
  }
});

// =================== SEARCH ENDPOINTS ===================

// Search movies
app.get('/api/search', async (req, res) => {
  try {
    const { query, page = 1 } = req.query;
    
    if (!query) {
      return res.status(400).json({ error: 'Arama sorgusu gerekli' });
    }
    
    console.log(`ğŸ” Multi-searching for query: "${query}" (page: ${page})`);
    console.log('TMDB_API_KEY exists:', !!TMDB_API_KEY);
    
    const response = await axios.get(`${TMDB_BASE_URL}/search/multi`, {
      params: {
        api_key: TMDB_API_KEY,
        language: 'tr-TR',
        query: query,
        page: page,
        include_adult: false
      }
    });
    
    // SonuÃ§larÄ± media_type'a gÃ¶re iÅŸle
    const results = response.data.results.map(item => {
      const baseData = {
        id: item.id,
        media_type: item.media_type,
        popularity: item.popularity
      };

      if (item.media_type === 'movie') {
        return {
          ...baseData,
          title: item.title,
          originalTitle: item.original_title,
          overview: item.overview,
          posterPath: item.poster_path ? `https://image.tmdb.org/t/p/w500${item.poster_path}` : null,
          backdropPath: item.backdrop_path ? `https://image.tmdb.org/t/p/w1280${item.backdrop_path}` : null,
          releaseDate: item.release_date,
          voteAverage: item.vote_average,
          voteCount: item.vote_count
        };
      } else if (item.media_type === 'tv') {
        return {
          ...baseData,
          title: item.name,
          originalTitle: item.original_name,
          overview: item.overview,
          posterPath: item.poster_path ? `https://image.tmdb.org/t/p/w500${item.poster_path}` : null,
          backdropPath: item.backdrop_path ? `https://image.tmdb.org/t/p/w1280${item.backdrop_path}` : null,
          releaseDate: item.first_air_date,
          voteAverage: item.vote_average,
          voteCount: item.vote_count
        };
      } else if (item.media_type === 'person') {
        return {
          ...baseData,
          name: item.name,
          profilePath: item.profile_path ? `https://image.tmdb.org/t/p/w500${item.profile_path}` : null,
          knownFor: item.known_for ? item.known_for.map(work => ({
            id: work.id,
            title: work.title || work.name,
            media_type: work.media_type,
            releaseDate: work.release_date || work.first_air_date
          })) : [],
          knownForDepartment: item.known_for_department
        };
      }

      return baseData;
    });

    res.json({
      page: response.data.page,
      results: results,
      total_pages: response.data.total_pages,
      total_results: response.data.total_results,
      query: query
    });
  } catch (error) {
    console.error('ğŸš¨ Multi-search API isteÄŸi sÄ±rasÄ±nda detaylÄ± hata:', {
      message: error.message,
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data,
      config: {
        url: error.config?.url,
        params: error.config?.params
      },
      code: error.code,
      searchQuery: req.query.query
    });
    res.status(500).json({ status: 'Failed to search', error: error.message });
  }
});

// Get person credits (movies and TV shows)
app.get('/api/person/:personId', async (req, res) => {
  try {
    const { personId } = req.params;
    console.log(`ğŸ‘¤ Fetching credits for person ${personId} from TMDB...`);
    console.log('TMDB_API_KEY exists:', !!TMDB_API_KEY);
    
    // Oyuncunun bilgilerini al
    const personResponse = await axios.get(`${TMDB_BASE_URL}/person/${personId}`, {
      params: {
        api_key: TMDB_API_KEY,
        language: 'tr-TR'
      }
    });

    // Oyuncunun filmografisini al
    const creditsResponse = await axios.get(`${TMDB_BASE_URL}/person/${personId}/combined_credits`, {
      params: {
        api_key: TMDB_API_KEY,
        language: 'tr-TR'
      }
    });

    // Cast listesini iÅŸle, temizle ve akÄ±llÄ± sÄ±ralama uygula
    const credits = creditsResponse.data.cast
      // Ã–nce veriyi temizle - tarih alanÄ± olmayan girdileri filtrele
      .filter(item => {
        const hasDate = (item.media_type === 'movie' && item.release_date) || 
                       (item.media_type === 'tv' && item.first_air_date);
        return hasDate;
      })
      // Veriyi dÃ¶nÃ¼ÅŸtÃ¼r
      .map(item => {
        const baseData = {
          id: item.id,
          media_type: item.media_type,
          popularity: item.popularity,
          character: item.character,
          order: item.order !== undefined ? item.order : 999 // order yoksa en sona at
        };

        if (item.media_type === 'movie') {
          return {
            ...baseData,
            title: item.title,
            originalTitle: item.original_title,
            overview: item.overview,
            posterPath: item.poster_path ? `https://image.tmdb.org/t/p/w500${item.poster_path}` : null,
            backdropPath: item.backdrop_path ? `https://image.tmdb.org/t/p/w1280${item.backdrop_path}` : null,
            releaseDate: item.release_date,
            voteAverage: item.vote_average,
            voteCount: item.vote_count
          };
        } else if (item.media_type === 'tv') {
          return {
            ...baseData,
            title: item.name,
            originalTitle: item.original_name,
            overview: item.overview,
            posterPath: item.poster_path ? `https://image.tmdb.org/t/p/w500${item.poster_path}` : null,
            backdropPath: item.backdrop_path ? `https://image.tmdb.org/t/p/w1280${item.backdrop_path}` : null,
            releaseDate: item.first_air_date,
            voteAverage: item.vote_average,
            voteCount: item.vote_count
          };
        }

        return null;
      })
      .filter(item => item !== null)
      // AkÄ±llÄ± sÄ±ralama uygula
      .sort((a, b) => {
        // Ã–nce role gÃ¶re sÄ±rala (dÃ¼ÅŸÃ¼k order deÄŸeri daha Ã¶nemli - baÅŸrol vs yan rol)
        if (a.order < b.order) return -1;
        if (a.order > b.order) return 1;

        // EÄŸer roller aynÄ±ysa, tarihe gÃ¶re sÄ±rala (yeni olan daha Ã¶nemli)
        const dateA = new Date(a.releaseDate);
        const dateB = new Date(b.releaseDate);
        return dateB - dateA; // En yeni en Ã¼stte
      })
      .slice(0, 20); // Ä°lk 20 filmi al

    console.log(`âœ… ${credits.length} yapÄ±m bulundu ve akÄ±llÄ± sÄ±ralama uygulandÄ± (ilk 20 tanesi gÃ¶steriliyor)`);

    res.json({
      person: {
        id: personResponse.data.id,
        name: personResponse.data.name,
        profilePath: personResponse.data.profile_path ? `https://image.tmdb.org/t/p/w500${personResponse.data.profile_path}` : null,
        knownForDepartment: personResponse.data.known_for_department
      },
      credits: credits
    });

  } catch (error) {
    console.error('ğŸš¨ Person credits API isteÄŸi sÄ±rasÄ±nda detaylÄ± hata:', {
      message: error.message,
      status: error.response?.status,
      statusText: error.response?.statusText,
      data: error.response?.data,
      config: {
        url: error.config?.url,
        params: error.config?.params
      },
      code: error.code,
      personId: req.params.personId
    });
    res.status(500).json({ status: 'Failed to fetch person credits', error: error.message });
  }
});

// Environment variables kontrolÃ¼ - server baÅŸlangÄ±cÄ±nda
console.log('ğŸ”§ Environment Variables Check:');
console.log('TMDB_API_KEY:', process.env.TMDB_API_KEY ? 'âœ… Mevcut' : 'âŒ Eksik');
console.log('GEMINI_API_KEY:', process.env.GEMINI_API_KEY ? 'âœ… Mevcut' : 'âŒ Eksik');
console.log('PORT:', process.env.PORT || 'Default 5000');

app.listen(PORT, () => {
  console.log(`ğŸ¬ CineMind Backend server running on port ${PORT}`);
  console.log(`ğŸ”— Health check: http://localhost:${PORT}/api/health`);
});
